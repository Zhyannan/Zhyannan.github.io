<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端基本知识]]></title>
    <url>%2F2016%2F07%2F20%2Fhtml%2F</url>
    <content type="text"><![CDATA[一. 了解前端1. 什么是前端前端即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5，CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，完美的动效设计，给用户带来极高的用户体验。 2. 前端三大块 这三个是前端开发中最基本也是最必须的三个技能。前端的开发中，在页面的布局时， HTML将元素进行定义，CSS对展示的元素进行定位，再通过JavaScript实现相应的效果和交互。虽然表面看起来很简单，但这里面需要掌握的东西绝对不会少。在进行开发前，需要对这些概念弄清楚、弄明白，这样在开发的过程中才会得心应手。 Html指的是超文本标记语言 (Hyper Text Markup Language)，这个也是我们网页最常用普通的语言了，经历了多个版本的发展，已经发展到5.0版了, 即HTML5。 Css级联样式表（Cascading Style Sheet）简称“CSS”，通常又称为“风格样式表（Style Sheet）”，它是用来进行网页风格设计的。比如，如果想让链接字未点击时是蓝色的，当鼠标移上去后字变成红色的且有下划线，这就是一种风格。通过设立样式表，可以统一地控制HTML中各标志的显示属性。级联样式表可以使人更能有效地控制网页外观。使用级联样式表，可以扩充精确指定网页元素位置，外观以及创建特殊效果的能力。 JavaScriptJavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 二. HTML1. 了解HTML我们可以通过查看源代码的形式, 看到制作出来的网页 通过仔细观察网页源代码我们可以知道: 制作网页的语言是用 “&lt;” “&gt;” 括起来的. 有些是成对出现,有些不是 —–&gt; 我们一般称这样用尖括号括起来的语言为 HTML HTML 是 Hyper Text Markup Language 的首字母简写, 意思是超文本标记语言, 超文本指的是超链接, 标记指的是标签, 是一种用来制作网页的语言, 这种语言由一个个的标签组成, 用这种语言制作的文件保存的是一个文本文件, 文件的扩展名为 .html 或者 .htm 2. HTML文档的基本结构html文件的基本结构为: 12345678910&lt;!DOCTYPE html&gt; &lt;!--html的文档声明,声明当前html文档的版本--&gt;&lt;html&gt; &lt;!--根标签: html开始标签 --&gt; &lt;head&gt; &lt;!--html标签中的第一个子标签: head开始标签--&gt; &lt;meta charset="UTF-8"&gt; &lt;!--单个标签meta: 主要用于当前文档设置, 这里设置的是文档的编码格式 utf-8--&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!--title标签: 主要用于设置当前文档标题--&gt; &lt;/head&gt; &lt;!--html标签中的第一个子标签: head结束标签--&gt; &lt;body&gt; &lt;!--html标签中的第二个子标签: body开始标签--&gt; &lt;/body&gt; &lt;!--html标签中的第二个子标签: body结束标签--&gt;&lt;/html&gt; &lt;!--根标签: html结束标签 --&gt; 注意: html语言中注释的写法: 快捷键: ctrl + / 取消注释: ctrl + / 说明: 基本上所有的html文件都是按照这样的格式作为模板进行开发. head标签的主要作用: 网页的设置 资源的引用 head标签中的内容一般不会显示在网页上. body中的内容通常用于网页显示 3. 快速创建HTML文档我们可以新建一个.html文件, 在文件中快速创建基本标签: 快速创建的方法是: 在文件中敲一个 “ ! “ 然后按 tab 键 即可: 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; body的内容&lt;/body&gt;&lt;/html&gt; 我们可以看到,这样就可以快速的创建一个基本的html文档了, 我们可以在这个文档中快速的编写代码 说明: lang=”en”: 声明这个网页的语言是英文, 如果是中文则为: lang=”zh-CN”, 主要是做统计使用, 国内网页一般不关心这个值. 第五行的主要作用是: 让网页在移动端观看时, 网页不缩放. 第六行的主要作用是: 如果网页在 IE 浏览器上观看, 让 IE 以最高版本显示网页 4. HTML标签 学习 HTML 语言就是学习标签的用法, HTML 标签有20多个, 学会这些标签的使用, 就基本上学会了 HTML的使用 1. 认识标签:在html语言中, 用尖括号括起来的部分, 我们成为标签. 2. 标签的了解: 成对的标签 单个的标签 无论是成对的标签还是单个的标签,都需要用 “ &lt; &gt; “ 括起来 例如: 12345678910111213141516 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;我的主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="#"&gt;这是个链接&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;img src="../day001/image.png" alt=""&gt;&lt;/body&gt;&lt;/html&gt; 3. 标签的属性有些标签内部有这样的设置: 123&lt;img src="../day001/image.png" alt=""&gt; &lt;div class="box"&gt;&lt;/div&gt; 其中 src=” “ 和 alt=” “ 这部分内容, 我们称之为当前标签的属性. 说明: 有些标签的属性是相同的, 有些标签的属性是不同的. 通过标签的属性,我们可以给当前的标签设置不同的内容. 总结: 我们只需要知道标签的尖括号内部添加的设置是属性即可 html 常用标签的属性我们在学习的过程中慢慢掌握. 4. 标签的分类 注意: 在前端中, 元素指的就是标签, 所以我们有时候说: xx元素, 即指的是 xx标签 标签按照显示的不同, 可以分为两类: 块元素 (行元素) 内联元素 (行内元素) 块元素的特点: 单个块元素在浏览器中默认独占一行 两个块元素不能够在一行显示, 他们会自动换成两行显示 块元素可以设置宽高等属性. 内联元素: 多个内联元素可以在一行显示 内联元素不能够设置宽高, 设置了也没有用, 不会显示出效果 内联元素的宽高由他们本身的内容多少来支撑, 内容多,宽高自动增加. 常用的块元素标签:1. 标题标签 表示文档的标题, 除了具有块元素基本特征之外, 还含有默认的外边距和字体大小 123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; 2.段落标签: 表示文档中的一个文字段落, 除了具有块元素基本特征, 还含有默认的外边距 12345678910111213141516171819&lt;p&gt; 既然你诚心诚意的问了， 我们就大发慈悲的告诉你！ 为了防止世界被破坏， 为了守护世界的和平； 贯彻爱与真实的邪恶， 可爱又迷人的反派角色~~ 武藏！ 小次郎！ 我们是穿梭在银河的火箭队！白洞，白色的明天在等着我们！！ 就是这样~喵~~~~ &lt;/p&gt;段落标签中如果想要强制换行,需要使用&lt;br&gt;标签, 这个标签是个单个标签,所以只有一个.另外在html中, 如果想要写大于号, 小于号, 或者空格等, 需要使用代码来实现, 这样更加优雅~代码实现大于号: &amp;gt;代码实现小于号: &amp;lt;代码实现空格: &amp;nbsp; 3. 通用块容器标签 div 表示文档中一块内容, 具 有块元素基本特性, 没有其他默认样式 1234567891011121314&lt;div&gt;这是一个div元素&lt;/div&gt;&lt;div&gt;这是第二个div元素&lt;/div&gt;&lt;div&gt; &lt;h3&gt;自我介绍&lt;/h3&gt; &lt;p&gt; 姑娘貌美一枝花，才学素养人品佳。 活泼开朗不八卦，头脑敏锐有想法。 踏实奋进不做假，乐于求知肯深挖。 舞文弄墨擅策划，慧心妙舌喜表达。 交友广泛爱分享，微博日日落不下。 四年深造象牙塔，学习实践两手抓。 只待应届招聘季，我花开后百花杀。 &lt;/p&gt;&lt;/div&gt; 常用内联元素标签1.超链接标签 a 链接到另外一个网页, 具有内联元素基本特征, 默认文字蓝色, 有下划线 1234567&lt;a href=&quot;02.html&quot;&gt;第二个网页&lt;/a&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度网站&lt;/a&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;&lt;img src=&quot;images/logo.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;默认链接&lt;/a&gt;&lt;a href=&quot;http://www.itcast.cn&quot;&gt;原来的窗口打开界面&lt;/a&gt;&lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot;&gt;新窗口打开界面&lt;/a&gt; 说明: a 标签的 href 属性可以添加 # 号, 这个是缺省链接地址: 不确定地址时, 我们可以临时使用 # 来占位,确定后替换即可 如果想要跳转到当前页面的最上方时, 可以使用 # a 标签有 target 属性 如果不设置该属性, 在当前页面打开新页面 如果设置该属性, 则会在新窗口中打开新页面 2.通用内联容器标签 span 具有内联元素基本特性, 没有其他默认样式 我们一般在文字段落的中间部分强调某一部分的时候调用span,添加样式,从而改变强调的部分的样式: 例如: 这是一段文字,其中梅总需要强调,所以我们可以使用span来完成强调的操作. 1&lt;p&gt;这是一个段落文字, 段落文字中有&lt;span&gt;特殊标志或者样式&lt;/span&gt;的文字&lt;/p&gt; 3. 图片标签 img 在网页中插入图片, 具有内联元素基本特性, 但是它支持宽高设置 1&lt;img src=&quot;images/pic.png&quot; alt=&quot;图片&quot;&gt; 说明: src属性主要是添加要展示的图片地址 alt属性的作用: 图片加载失败时, 显示的提示信息 搜索引擎在收录图片时, 根据这个属性值来收录图片 制作无障碍网页, 方便盲人的读屏软件读取. 特殊的一些标签:空格: 在html中, 空格一般会用: &amp;nbsp;表示 回车: 在html中回车换行一般用&lt;br&gt;表示 小于号( &lt; ): 在html中一般用&amp;lt;表示 大于号( &gt; ): 在html中一般用&amp;gt;表示 删除标签: del 或者 ( s ) 倾斜标签: em 或者 ( i ) 下划线标签: ins 或者 ( u ) 字体变粗: strong 或者 b 总结: HTML 整体是由标签组成的, 各个标签的功能很多都是重复的 同学们学习标签用法的时候多多练习即可 标签整体分为: 块级标签 和 行内标签 块级标签可以设置宽高值, 独占一行 行内标签自动设置宽高值, 一行内可以有多个 一般来说, 块级元素可以包含行内元素,行内元素不能包含块级元素. 特殊情况, 需要记住: p 标签不能嵌套 div a 标签用于跳转(超链接) [跳转网页, 跳转页面, 跳转文件等] 标题标签用于设置标题, 共有6级 div就是一个无色透明的容器,看不见,摸不到 img标签主要用于设置图片 p 标签就是paragraph(段落) 通常用于包裹段落 span是一个行内元素通常用于p标签内部,个别文字设置时使用. 5. HTML布局网页布局原理: 标签在网页中会显示成一个个的方块,先按照行的方式, 把网页划分为多个行, 再到行里面划分列, 也就是说在表示行的标签中在嵌套标签来表示列, 标签的嵌套产生叠加效果. 上图实例: 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 外面的容器 --&gt; &lt;div&gt; &lt;!-- 第一行 --&gt; &lt;div&gt; &lt;h3&gt;今日头条&lt;/h3&gt; &lt;a href="#"&gt;更多&amp;gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;!-- 第二行 --&gt; &lt;img src="images/banner.jpg" alt="banner"&gt; &lt;!-- 第三行 --&gt; &lt;p&gt; 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的 智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解 智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器 人、语言识别、图像 识别、自然语言处理和专家系统等。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 标签语义化 在布局中需要尽量使用带语义的标签, 使用带语义的标签的目的首先是为了让搜索引擎能更好的理解网页的结构,提高网站在搜索中的排名(也叫作SEO), 其次是方便代码的阅读和维护 带语义的标签: h1 —- h6: 表示标题 p: 表示段落 img : 表示图片 a: 表示链接 不带语义 的标签: div: 表示一个容器 span: 表示行内的一块内容 所以我们要根据网页上显示的内容, 使用合适的标签, 可以优化之前的代码. 本章总结: 本章需要背诵的内容: 块级标签和行内标签的概念, 以及各自的标签 块级标签我们学习了三个: div h系列 p 行内标签我们学习了三个: span img a html布局只是一个思想, 理解即可. 特殊标签也是了解即可,不需要记忆 HTML文档的基本格式需要大家掌握, 创建方式需要背诵: ! + tab 空格: &amp;nbsp; 换行: &lt;br&gt; 大于号: &amp;gt; 小于号: &amp;lt;需要背诵.否则作业无法完成 标签语义化, 标签的定义, 标签中属性的定义, 都是概念需要了解,不需要记忆. 三. CSS介绍 为了让网页元素的样式更加的丰富, 也为了让网页的内容和样式能拆分开, CSS由此而诞生. CSS是 Cascading Style Sheets 的首写字母缩写,意思是层叠样式表. 有了CSS, html 中大部分表现样式的标签就废弃不用了, html只负责文档的结构和内容, 表现形式完全交给CSS, 这样使得html文档变得更加简洁. 1. CSS基本语法1234567CSS使用格式:选择器 &#123; 属性 : 值; 属性 : 值; ...&#125; 说明: 选择器是将样式和页面元素关联起来的名称 属性名是希望设置的样式属性, 每个属性有一个或者多个值 属性和值之间用冒号隔开 一个属性和值与下一个属性和值之间用分号, 最后一个分号可以省略. 例如: 12345div &#123; width: 100px; height: 100px; background: gold;&#125; 2. CSS引入方法 CSS样式导入HTML中有三种方式 1.内联式: 通过标签的 style 属性, 在标签上直接写样式. 123&lt;div style=&quot;width:100px; height:100px; background:red;&quot;&gt; 这是个div标签&lt;/div&gt; 2. 嵌入式: 通过 style 标签, 在网页上创建嵌入的样式表. 123456789&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; div &#123; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt; 3.外联式: 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/样式文件名.css&quot;&gt; 3. CSS选择器 CSS选择器: 帮助我们找寻标签, 找到之后 添加样式 CSS 的四种基本选择器: 通用选择器 ( * ) 标签选择器 ( 标签名 ) 类选择器 ( class ) id 选择器 ( id ) CSS 组合选择器: 多元素选择器 后代选择器(层级) 子元素选择器 兄弟选择器 CSS 属性选择器: 属性选择器 3.1 基础选择器:1. 通用选择器 通用选择器, 匹配任何元素: 1234567使用格式:* &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 1234* &#123; margin: 0px; padding: 0px;&#125; 有些标签自动会增加一些内边距和外边距等样式, 我们可以使用这个选择器把默认的都给去掉 2.标签选择器 标签选择器, 此种选择器影响范围大, 一般用来做一些通用设置, 或用在层级选择器中. 123456通用格式:标签名 &#123; 属性名: 值; ...&#125; 例如: 123456789101112131415CSS部分:&lt;style&gt; div &#123; color: red; &#125; p &#123; font-size: 18px; &#125;&lt;/style&gt;HTML部分:&lt;div&gt;这里是html部分&lt;/div&gt;&lt;p&gt;html区域的p标签&lt;/p&gt; 一旦使用标签选择器,则当前页面上的所有该标签全部都有该样式. 这一点需要注意 3.类选择器 通过类名来选择元素, 一个类可应用于多个元素, 一个元素上也可以使用多个类 应用灵活, 可复用, 是css中应用最多的一种选择器 123456常见格式:.类名 &#123; 属性名: 值; ...&#125; 举例: 12345678910111213141516171819202122232425CSS部分:&lt;style&gt; .blue &#123; color: blue; &#125; .header &#123; font-size: 19px; &#125; .box &#123; color:orange; &#125; /* 这是CSS注释的写法,可以作为单行注释,也可以作为多行注释 */ /* 针对下面的代码, 如果我们想单独选中div, 则可以这样写: */ div.blue &#123; /*文字变为斜体*/ font-style: italic; &#125;&lt;/style&gt;HTML部分:&lt;div&gt;这是div标签&lt;/div&gt;&lt;div class="blue"&gt;这个标签的字体颜色会变成蓝色,是因为class选择器&lt;/div&gt;&lt;p class="blue"&gt;这是div下面的p标签,也会变成蓝色,因为用的是同样的选择器,名字也一样&lt;/p&gt;&lt;h3 class="blue header box"&gt;这个标签有好多个class类名, 则都会加载不同类名下面的样式, 形成重叠效果&lt;/h3&gt;&lt;p class="header"&gt;这个标签的类名和上面的有一样的,所以上面的header样式也会加载在这个标签上&lt;/p&gt; 4. id选择器 通过 id 名来选择元素，元素的 id 名称不能重复，所以一个样式设置项只能对应于页面上一个元素，不能复用，id 名一般给程序使用，所以不推荐使用id作为选择器。 12345使用格式:#ID名 &#123; 属性名: 值&#125; 举例： 123456789101112131415CSS部分: &lt;style&gt; #box &#123; color:red &#125; #box1 &#123; background:blue; &#125;&lt;/style&gt;HTML部分:&lt;p id="box"&gt;这是第一个段落标签&lt;/p&gt; &lt;p id="box1"&gt;这是第二个段落标签&lt;/p&gt; &lt;p&gt;这是第三个段落标签&lt;/p&gt; 3.2 组合选择器1. 多元素选择器 同时匹配所有 E元素 和 F元素, E和F之间用逗号分隔: 1234567使用格式: E,F &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 123456789101112CSS部分:&lt;style&gt; .box,p &#123; color: red; &#125;&lt;/style&gt;HTML部分:&lt;div class="box"&gt;这是一个美丽的div&lt;/div&gt;&lt;p&gt;美丽div下面的段落标签p&lt;/p&gt; 2.后代选择器: 主要应用在标签嵌套的结构中,层级选择器, 是结合上面两种选择器来写的选择器, 它可与标签选择器结合使用,减少命名,同时也可以通过层级, 限制样式的作用范围 1234567使用方式:E F &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 1234567891011121314151617181920212223CSS部分:&lt;style&gt; .con &#123; width: 100px; height: 100px; &#125; div p &#123; color: red; &#125; .con .pbox &#123; color: pink; &#125;&lt;/style&gt;HTML部分:&lt;div class="con"&gt; &lt;p&gt;这里是span标签的内容&lt;/p&gt; &lt;div class="pink"&gt; 这里是div中的div标签 &lt;p class="pbox"&gt;粉红色啊粉红色&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 层级选择器: 按照标签的层级来匹配对应的标签 3. 子代选择器 E &gt; F 匹配所有 E元素的 子元素F 1234567使用格式: E &gt; F &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 123456789101112131415161718192021222324252627CSS部分:&lt;style&gt; div&gt;p &#123; color: red; &#125; div&gt;div&#123; font-size:30px; &#125; /* 选中了a标签, 但是div内部的内容是没有改变的,说明可以确切的选中某一个 */ .box&gt;a &#123; background: pink; &#125;&lt;/style&gt;HTML部分:&lt;div class="con"&gt; &lt;p&gt;这是div元素的子集p元素&lt;/p&gt; &lt;div class="box"&gt; div标签的内容部分 &lt;a href="#"&gt;第二个div的子集:a元素&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 4. 毗邻选择器 匹配所有紧随 E元素 之后的同级元素F (向下寻找) 1234567使用格式: E + F &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 123456789101112CSS部分:&lt;style&gt; .box + div &#123; color: red; &#125;&lt;/style&gt;HTML部分:&lt;div&gt;第一个div,啦啦啦~&lt;/div&gt;&lt;div class="box"&gt;第二个div,啦啦啦~&lt;/div&gt;&lt;div&gt;第三个div,啦啦啦~&lt;/div&gt; 3. 3 属性选择器1. 第一种属性选择器的使用 12345678910使用方法: [attr] &#123; 属性名: 值; 属性名: 值; ...&#125;[title] &#123; &#125; 例如: 123456789101112CSS部分:&lt;style&gt; [name] &#123; color: red; &#125;&lt;/style&gt;HTML部分: &lt;div&gt; hello1 &lt;/div&gt;&lt;div name="peter"&gt; hello1 &lt;/div&gt;&lt;div title="haha"&gt; hello1 &lt;/div&gt;&lt;div&gt; hello1 &lt;/div&gt; 2. 第二种属性选择器的使用 1234567使用方法:E[attr=val] &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 123456789101112CSS部分:&lt;style&gt; [name="peter"] &#123; color: red; &#125;&lt;/style&gt;HTML部分: &lt;div&gt; hello1 &lt;/div&gt;&lt;div name="peter"&gt; hello1 &lt;/div&gt;&lt;div name="bill"&gt; hello1 &lt;/div&gt;&lt;div&gt; hello1 &lt;/div&gt; 3.4 伪类选择器1. 伪类选择器 常用的伪类选择器有hover，表示鼠标悬浮在元素上时的状态。 12345678910111213141516171819202122CSS部分: &lt;style&gt; .box1 &#123; width:100px; height:100px; background:gold; &#125; .box1:hover &#123; width:300px; &#125;&lt;/style&gt;HTML部分: &lt;div class="box1"&gt;别看村子不咋大呀， 有山有水有树林， 邻里相亲多和睦， 老少爷们也合群&lt;/div&gt;补充: #input:focus &#123; outline: none; border: 2px solid red;&#125; 总结: CSS 选择器的主要目的是: 获取 HTML 元素, 获取到后给当前元素添加样式. CSS 选择器的种类非常多, 一般我们用不上, 把常用的学会即可. 标签选择器尽量少用, 覆盖面巨大. 不利于我们样式的单独调整. class 类选择器是经常使用的选择器. 可以多多练习 层级选择器 一般配合类选择器或者其他的选择器一起使用. 常用来获取大容器里面没有明确定义类名的元素 id 选择器偶尔使用, 使用它往往就是利用他的唯一性. 获取单个某个标签使用. 伪类选择器是需要设置特殊阶段的效果时, 添加的选择器, 知道即可 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; a:link &#123;color: red&#125; /* 未访问时的状态 */ a:visited &#123;color: orange&#125; /* 已访问过的状态 */ a:hover &#123;color: pink&#125; /* 鼠标移动到链接上时的状态 */ a:active &#123;color: yellow&#125; /* 鼠标按下去时的状态 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;b&gt;&lt;a href="/index.html" target="_blank"&gt;这是一个链接。&lt;/a&gt;&lt;/b&gt; &lt;/p&gt; &lt;p&gt; &lt;b&gt;注释：&lt;/b&gt; 在 CSS 定义中，a:hover 必须位于 a:link 和 a:visited 之后，这样才能生效！ &lt;/p&gt; &lt;p&gt; &lt;b&gt;注释：&lt;/b&gt; 在 CSS 定义中，a:active 必须位于 a:hover 之后，这样才能生效！ &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 注意嵌套规则: 块级元素 可以包含内联元素或某些块级元素, 但是内联元素不能包含块级元素,它只能包含其他内联元素 有几个特殊的块级元素只能包含内联元素,不能包含块级元素. 如h1, h2, h3, h4, h5, h6, p li 内可以包含 div 块级元素与块级元素并列 , 内联元素与内联元素并列. 补充: (仅需要了解) 初始化CSS (需要了解) 为什么要初始化CSS？ ​ 建站老手都知道，这是为了考虑到浏览器的兼容问题，其实不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 ​ 最简单的初始化方法就是： {padding: 0; margin: 0;} 。有很多人也是这样写的。这确实很简单，但有人就会感到疑问：号这样一个通用符在编写代码的时候是快，但如果网站很大，CSS样式表文件很大，这样写的话，他会把所有的标签都初始化一遍，这样就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间。 ​ 写过css的都知道每个网页引进的css首先都需要初始化，而出名的css reset有YUI css reset（QQ、淘宝等都出现他的影子），业内用的最多的还有Erik Meyer’s CSS Reset。 ​ CSS初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，所以开发时的第一件事可能就是如何把它们统一。如果没对CSS初始化往往会出现浏览器之间的页面差异。每次新开发网站或新网页时候通过初始化CSS样式的属性，为我们将用到的CSS或html标签更加方便准确，使得我们开发网页内容时更加方便简洁，同时减少CSS代码量，节约网页下载时间。 ​ 雅虎工程师提供的CSS初始化示例代码 ​ body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td { margin:0; padding:0; } 4. CSS进阶布局常用属性样式: 属性 作用 举例 width 设置元素(标签)的宽度 width: 200px; height 设置元素(标签)的高度 height: 200px; background 设置元素背景色或者背景图片(详看下面) background: pink; border 设置元素四周的边框 border: 1px solid pink; border-top 设置元素顶部边框 border-top: 1px solid/ dashed pink; border-left 设置元素左边边框 border-left: 1px solid pink; border-right 设置元素右边边框 border-right: 1px solid pink; border-bottom 设置元素底部边框 border-bottom: 1px solid pink; 文本常用样式属性: color 设置文字的颜色 color: red; font-size 设置文字的大小 font-size: 12px; font-family 设置文字的字体 font-family: ‘Microsoft Yahei’; (微软雅黑) font-weight 设置文字是否加粗 font-weight: bold; (bold:加粗 normal: 正常) line-height 设置文字的行高 line-height: 24px; (文字高度加上文字上下间距共计24px) text-decoration 设置文字的下划线 text-decoration:none; (取消下划线) 提示:样式中的注释 123456/* 设置头部的样式 */.header&#123; width:960px; height:80px; background:gold;&#125; 浮动: ( float ) 我们有时候为了让一行能够显示多个元素, 会设置元素的float属性: 先来回顾一下 block 元素和 inline 元素在页面中的排列方式: block 元素通常被实现为独立的一块, 独占一行, 多个 block 元素会各自新起一行, 默认 block 元素宽度自动填满其父元素宽度. block 元素可以设置 width, height, margin, padding 属性. inline 元素不会独占一行, 多个相邻的行内元素会排列在一行里, 知道一行排列不下, 才会新换一行, 其宽度随元素的内容而变化. inline 元素设置width, height属性无效. inline 元素的margin 和 padding 属性. 水平方向的padding-left, padding-right, margin-left, margin-right 都产生边距效果; 但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom 不会产生边距效果. 常见的块级元素有 div, form , table, p, h1~h5, ol, ul等 常见的内联元素有 span, a, strong, em, label, input, select, textarea, img, br等. 只有绝对定位( absolute )和浮动( float ) 才会脱离文档流 需要注意的是: 使用 float 脱离文档流时, 其他盒子会无视这个元素, 但其他盒子内的文本依然会为这个元素让出位置, 环绕在周围(可以说是部分无视). 而对于使用 position:absolute 脱离文档流的元素, 其他盒子与其他盒子内的文本都会无视它(可以说是完全无视) 浮动的表现 : ​ 定义: 浮动的框可以向左或向右移动, 直到它的外边缘碰到包含框或另一个浮动框的边框为止. 由于浮动框不在文档的普通流中,所以文档的普通流中的浮动框之后的块框表现的就像浮动框不存在一样. (注意 这里是块框而不是内联元素; 浮动框只对它后面的元素造成影响 ) 注意: 当初float 被设计的时候就是用来完成文本环绕的效果, 所以文本不会被挡住, 这是 float 的特性, 即 float 是一种不彻底的脱离文档流的方式. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1 &#123; width: 100px; height: 100px; background-color: pink; &#125; .div2 &#123; width: 200px; height: 100px; background-color: blue; &#125; .div3 &#123; width: 100px; height: 200px; background-color: green; &#125; .div4 &#123; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;div class="div4"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 特别注意 设置某一个元素为float 之后, 当前元素是否往前一个位置飘动,取决于上一个元素是否设置了float,如果设置了则飘动,如果没有设置,则还是在原来的位置, 只是飘起来, 不飘动. 如果一个容器中有两个子元素, 两个子元素都设置浮动浮起来之后,则容器会被压缩为一点. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; background-color: pink; &#125; .sub1 &#123; width: 100px; height: 100px; background-color: limegreen; float: left; &#125; .sub2 &#123; width: 100px; height: 100px; background-color: olive; float: left; &#125; .box2 &#123; width: 400px; height: 30px; background-color: orangered; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="sub1"&gt;&lt;/div&gt; &lt;div class="sub2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 补充: 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 css 浮动: 请看下图，当把框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘： 再请看下图，当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。 如果把所有三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。 如下图所示，如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”： 5. CSS布局演示通过样式,并且参照下图, 可以把之前写的布局作进一步的调整, 完成最终的布局效果: 参考文字: 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width:285px; height: 310px; border-bottom: 1px solid #c8dcf2; border-top: 1px solid #c8dcf2; &#125; .header &#123; width:285px; height: 40px; &#125; .header h3 &#123; margin:0px; font-family: 'Microsoft Yahei'; font-size: 16px; color: #172c45; line-height: 40px; float: left; &#125; .header a &#123; font-size: 12px; font-family: 'Microsoft Yahei'; color: #172c45; text-decoration: none; float: right; line-height: 40px; &#125; p &#123; font-size: 12px; font-family: 'Microsoft Yahei'; color: #737373; line-height: 20px; height:190px; width: 100%; &#125; img &#123; height:80px; width:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="header"&gt; &lt;h3&gt;今日头条&lt;/h3&gt; &lt;a href="#"&gt;更多&amp;gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;img src="./images/banner.jpg" alt="banner"&gt; &lt;p&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[辨析 Sass 中的 Map 和 List]]></title>
    <url>%2F2015%2F10%2F21%2Fdemo%2F</url>
    <content type="text"><![CDATA[如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。 使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。 测试表格 Variable Description site Sitewide information. page Page specific information and custom variables set in front-matter. config Site configuration theme Theme configuration. Inherits from site configuration. _ (single underscore) Lodash library path Path of current page url Full URL of current page env Environment variables 语法比较 测试标题 在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 min-width、max-width、font-size 和 line-height 四个样式。 Map 语法下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。 1234567891011121314151617181920212223242526$breakpoint-map: ( small: ( min-width: null, max-width: 479px, base-font: 16px, vertical-rhythm: 1.3 ), medium: ( min-width: 480px, max-width: 959px, base-font: 18px, vertical-rhythm: 1.414 ), large: ( min-width: 960px, max-width: 1099px, base-font: 18px, vertical-rhythm: 1.5 ), xlarge: ( min-width: 1100px, max-width: null, base-font: 21px, vertical-rhythm: 1.618 )); 多重列表语法下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 nth() 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。 123456$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618)); 遍历比较 测试标题 从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？ 遍历 Map我们可以使用如下的代码遍历 Map： 1@each $label, $map in $breakpoint-map &#123;&#125; 这里的变量 $label 和 $map 会随着对 $breakpoint-map 的遍历被动态地赋值，$label 将会被赋值为 $breakpoint-map 的 Key，而 $map 会被赋值为 $breakpoint-map 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 map-get() 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。 具体的做法就是使用 @each 遍历 Map，然后使用 map-get() 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历： 123456@each $label, $map in $breakpoint-map &#123; $min-width: map-get($map, min-width); $max-width: map-get($map, max-width); $base-font: map-get($map, base-font); $vertical-rhythm: map-get($map, vertical-rhythm);&#125; 遍历多重列表遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 map-get() 函数取特定值，直接遍历一遍即可获得特定值。 因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 map-get()，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符： 12@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#125; 慎用多重列表 测试标题 经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。 遗漏键值如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况： 1234567891011121314151617181920$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, 21px, 1.618));p &#123; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123; @if $min-width &#123; @include breakpoint( $min-width ) &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125; @else &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125;&#125; 当我们尝试运行这段代码时，结果肯定是错误地，因为在 $breakpoint-list 的最后一行，xlarge 被赋值给了 $label，1100px 被赋值给了 $min-width，21px 被赋值给了 $max-width, 1.618 被赋值给了 $base-font，最终导致 $vertical-rhythm 没有被赋值，结果就是 font-size 的属性值是错的，line-height 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。 如果我们使用 Map 来代替这里的多重列表，那么使用 map-get() 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。 查找特定列表在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 map-get() 函数可以快速定位到特定子 Map： 1$medium-map: map-get($maps, medium); 但如果要获取多种列表 medium 列表，麻烦可就大了： 123456789@function get-list($label) &#123; @each $list in $breakpoint-list &#123; @if nth($list, 1) == $label &#123; @return $list; &#125; &#125; @return null;&#125;$medium-list: get-list(medium); 这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 null。这实际上就是手工实现了 map-get() 的逻辑。 缺少原生的 Map 函数Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 map-merge() 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 join() 或 append() 来增加新列表，从而模拟出 map-merge() 的效果。 另一个实用的 Map 函数就是 map-has-key()，对于依赖 map-get() 的自定义函数来说，map-has-key() 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。 总结 Test Title 相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。 虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
