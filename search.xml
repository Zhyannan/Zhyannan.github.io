<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS-进阶]]></title>
    <url>%2F2016%2F07%2F21%2F2016-7-20-css-02%2F</url>
    <content type="text"><![CDATA[1. CSS进阶1.布局常用属性样式: 属性 作用 举例 width 设置元素(标签)的宽度 width: 200px; height 设置元素(标签)的高度 height: 200px; background 设置元素背景色或者背景图片(详看下面) background: pink; border 设置元素四周的边框 border: 1px solid pink; border-top 设置元素顶部边框 border-top: 1px solid/ dashed pink; border-left 设置元素左边边框 border-left: 1px solid pink; border-right 设置元素右边边框 border-right: 1px solid pink; border-bottom 设置元素底部边框 border-bottom: 1px solid pink; 2.文本常用样式属性: color 设置文字的颜色 color: red; font-size 设置文字的大小 font-size: 12px; font-family 设置文字的字体 font-family: ‘Microsoft Yahei’; (微软雅黑) font-weight 设置文字是否加粗 font-weight: bold; (bold:加粗 normal: 正常) line-height 设置文字的行高 line-height: 24px; (文字高度加上文字上下间距共计24px) text-decoration 设置文字的下划线 text-decoration:none; (取消下划线) 提示:样式中的注释 123456/* 设置头部的样式 */.header&#123; width:960px; height:80px; background:gold;&#125; 3.浮动: ( float ) 我们有时候为了让一行能够显示多个元素, 会设置元素的float属性: 先来回顾一下 block 元素和 inline 元素在页面中的排列方式: block 元素通常被实现为独立的一块, 独占一行, 多个 block 元素会各自新起一行, 默认 block 元素宽度自动填满其父元素宽度. block 元素可以设置 width, height, margin, padding 属性. inline 元素不会独占一行, 多个相邻的行内元素会排列在一行里, 知道一行排列不下, 才会新换一行, 其宽度随元素的内容而变化. inline 元素设置width, height属性无效. inline 元素的margin 和 padding 属性. 水平方向的padding-left, padding-right, margin-left, margin-right 都产生边距效果; 但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom 不会产生边距效果. 常见的块级元素有 div, form , table, p, h1~h5, ol, ul等 常见的内联元素有 span, a, strong, em, label, input, select, textarea, img, br等. 只有绝对定位( absolute )和浮动( float ) 才会脱离文档流 需要注意的是: 使用 float 脱离文档流时, 其他盒子会无视这个元素, 但其他盒子内的文本依然会为这个元素让出位置, 环绕在周围(可以说是部分无视). 而对于使用 position:absolute 脱离文档流的元素, 其他盒子与其他盒子内的文本都会无视它(可以说是完全无视) 浮动的表现 : ​ 定义: 浮动的框可以向左或向右移动, 直到它的外边缘碰到包含框或另一个浮动框的边框为止. 由于浮动框不在文档的普通流中,所以文档的普通流中的浮动框之后的块框表现的就像浮动框不存在一样. (注意 这里是块框而不是内联元素; 浮动框只对它后面的元素造成影响 ) 注意: 当初float 被设计的时候就是用来完成文本环绕的效果, 所以文本不会被挡住, 这是 float 的特性, 即 float 是一种不彻底的脱离文档流的方式. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1 &#123; width: 100px; height: 100px; background-color: pink; &#125; .div2 &#123; width: 200px; height: 100px; background-color: blue; &#125; .div3 &#123; width: 100px; height: 200px; background-color: green; &#125; .div4 &#123; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;div class="div4"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 特别注意 设置某一个元素为float 之后, 当前元素是否往前一个位置飘动,取决于上一个元素是否设置了float,如果设置了则飘动,如果没有设置,则还是在原来的位置, 只是飘起来, 不飘动. 如果一个容器中有两个子元素, 两个子元素都设置浮动浮起来之后,则容器会被压缩为一点. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; background-color: pink; &#125; .sub1 &#123; width: 100px; height: 100px; background-color: limegreen; float: left; &#125; .sub2 &#123; width: 100px; height: 100px; background-color: olive; float: left; &#125; .box2 &#123; width: 400px; height: 30px; background-color: orangered; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="sub1"&gt;&lt;/div&gt; &lt;div class="sub2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 补充: 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 2. CSS布局演示通过样式,并且参照下图, 可以把之前写的布局作进一步的调整, 完成最终的布局效果: 参考文字: 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width:285px; height: 310px; border-bottom: 1px solid #c8dcf2; border-top: 1px solid #c8dcf2; &#125; .header &#123; width:285px; height: 40px; &#125; .header h3 &#123; margin:0px; font-family: 'Microsoft Yahei'; font-size: 16px; color: #172c45; line-height: 40px; float: left; &#125; .header a &#123; font-size: 12px; font-family: 'Microsoft Yahei'; color: #172c45; text-decoration: none; float: right; line-height: 40px; &#125; p &#123; font-size: 12px; font-family: 'Microsoft Yahei'; color: #737373; line-height: 20px; height:190px; width: 100%; &#125; img &#123; height:80px; width:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="header"&gt; &lt;h3&gt;今日头条&lt;/h3&gt; &lt;a href="#"&gt;更多&amp;gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;img src="./images/banner.jpg" alt="banner"&gt; &lt;p&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-基础]]></title>
    <url>%2F2016%2F07%2F20%2F2016-7-20-css-01%2F</url>
    <content type="text"><![CDATA[CSS介绍 为了让网页元素的样式更加的丰富, 也为了让网页的内容和样式能拆分开, CSS由此而诞生. CSS是 Cascading Style Sheets 的首写字母缩写,意思是层叠样式表. 有了CSS, html 中大部分表现样式的标签就废弃不用了, html只负责文档的结构和内容, 表现形式完全交给CSS, 这样使得html文档变得更加简洁. 1. CSS基本语法1234567CSS使用格式:选择器 &#123; 属性 : 值; 属性 : 值; ...&#125; 说明: 选择器是将样式和页面元素关联起来的名称 属性名是希望设置的样式属性, 每个属性有一个或者多个值 属性和值之间用冒号隔开 一个属性和值与下一个属性和值之间用分号, 最后一个分号可以省略. 例如: 12345div &#123; width: 100px; height: 100px; background: gold;&#125; 2. CSS引入方法 CSS样式导入HTML中有三种方式 1.内联式: 通过标签的 style 属性, 在标签上直接写样式. 123&lt;div style=&quot;width:100px; height:100px; background:red;&quot;&gt; 这是个div标签&lt;/div&gt; 2. 嵌入式: 通过 style 标签, 在网页上创建嵌入的样式表. 123456789&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; div &#123; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt; 3.外联式: 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/样式文件名.css&quot;&gt; 3. CSS选择器 CSS选择器: 帮助我们找寻标签, 找到之后 添加样式 CSS 的四种基本选择器: 通用选择器 ( * ) 标签选择器 ( 标签名 ) 类选择器 ( class ) id 选择器 ( id ) CSS 组合选择器: 多元素选择器 后代选择器(层级) 子元素选择器 兄弟选择器 CSS 属性选择器: 属性选择器 3.1 基础选择器:1. 通用选择器 通用选择器, 匹配任何元素: 1234567使用格式:* &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 1234* &#123; margin: 0px; padding: 0px;&#125; 有些标签自动会增加一些内边距和外边距等样式, 我们可以使用这个选择器把默认的都给去掉 2.标签选择器 标签选择器, 此种选择器影响范围大, 一般用来做一些通用设置, 或用在层级选择器中. 123456通用格式:标签名 &#123; 属性名: 值; ...&#125; 例如: 123456789101112131415CSS部分:&lt;style&gt; div &#123; color: red; &#125; p &#123; font-size: 18px; &#125;&lt;/style&gt;HTML部分:&lt;div&gt;这里是html部分&lt;/div&gt;&lt;p&gt;html区域的p标签&lt;/p&gt; 一旦使用标签选择器,则当前页面上的所有该标签全部都有该样式. 这一点需要注意 3.类选择器 通过类名来选择元素, 一个类可应用于多个元素, 一个元素上也可以使用多个类 应用灵活, 可复用, 是css中应用最多的一种选择器 123456常见格式:.类名 &#123; 属性名: 值; ...&#125; 举例: 12345678910111213141516171819202122232425CSS部分:&lt;style&gt; .blue &#123; color: blue; &#125; .header &#123; font-size: 19px; &#125; .box &#123; color:orange; &#125; /* 这是CSS注释的写法,可以作为单行注释,也可以作为多行注释 */ /* 针对下面的代码, 如果我们想单独选中div, 则可以这样写: */ div.blue &#123; /*文字变为斜体*/ font-style: italic; &#125;&lt;/style&gt;HTML部分:&lt;div&gt;这是div标签&lt;/div&gt;&lt;div class="blue"&gt;这个标签的字体颜色会变成蓝色,是因为class选择器&lt;/div&gt;&lt;p class="blue"&gt;这是div下面的p标签,也会变成蓝色,因为用的是同样的选择器,名字也一样&lt;/p&gt;&lt;h3 class="blue header box"&gt;这个标签有好多个class类名, 则都会加载不同类名下面的样式, 形成重叠效果&lt;/h3&gt;&lt;p class="header"&gt;这个标签的类名和上面的有一样的,所以上面的header样式也会加载在这个标签上&lt;/p&gt; 4. id选择器 通过 id 名来选择元素，元素的 id 名称不能重复，所以一个样式设置项只能对应于页面上一个元素，不能复用，id 名一般给程序使用，所以不推荐使用id作为选择器。 12345使用格式:#ID名 &#123; 属性名: 值&#125; 举例： 123456789101112131415CSS部分: &lt;style&gt; #box &#123; color:red &#125; #box1 &#123; background:blue; &#125;&lt;/style&gt;HTML部分:&lt;p id="box"&gt;这是第一个段落标签&lt;/p&gt; &lt;p id="box1"&gt;这是第二个段落标签&lt;/p&gt; &lt;p&gt;这是第三个段落标签&lt;/p&gt; 3.2 组合选择器1. 多元素选择器 同时匹配所有 E元素 和 F元素, E和F之间用逗号分隔: 1234567使用格式: E,F &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 123456789101112CSS部分:&lt;style&gt; .box,p &#123; color: red; &#125;&lt;/style&gt;HTML部分:&lt;div class="box"&gt;这是一个美丽的div&lt;/div&gt;&lt;p&gt;美丽div下面的段落标签p&lt;/p&gt; 2.后代选择器: 主要应用在标签嵌套的结构中,层级选择器, 是结合上面两种选择器来写的选择器, 它可与标签选择器结合使用,减少命名,同时也可以通过层级, 限制样式的作用范围 1234567使用方式:E F &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 1234567891011121314151617181920212223CSS部分:&lt;style&gt; .con &#123; width: 100px; height: 100px; &#125; div p &#123; color: red; &#125; .con .pbox &#123; color: pink; &#125;&lt;/style&gt;HTML部分:&lt;div class="con"&gt; &lt;p&gt;这里是span标签的内容&lt;/p&gt; &lt;div class="pink"&gt; 这里是div中的div标签 &lt;p class="pbox"&gt;粉红色啊粉红色&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 层级选择器: 按照标签的层级来匹配对应的标签 3. 子代选择器 E &gt; F 匹配所有 E元素的 子元素F 1234567使用格式: E &gt; F &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 123456789101112131415161718192021222324252627CSS部分:&lt;style&gt; div&gt;p &#123; color: red; &#125; div&gt;div&#123; font-size:30px; &#125; /* 选中了a标签, 但是div内部的内容是没有改变的,说明可以确切的选中某一个 */ .box&gt;a &#123; background: pink; &#125;&lt;/style&gt;HTML部分:&lt;div class="con"&gt; &lt;p&gt;这是div元素的子集p元素&lt;/p&gt; &lt;div class="box"&gt; div标签的内容部分 &lt;a href="#"&gt;第二个div的子集:a元素&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 4. 毗邻选择器 匹配所有紧随 E元素 之后的同级元素F (向下寻找) 1234567使用格式: E + F &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 123456789101112CSS部分:&lt;style&gt; .box + div &#123; color: red; &#125;&lt;/style&gt;HTML部分:&lt;div&gt;第一个div,啦啦啦~&lt;/div&gt;&lt;div class="box"&gt;第二个div,啦啦啦~&lt;/div&gt;&lt;div&gt;第三个div,啦啦啦~&lt;/div&gt; 3. 3 属性选择器1. 第一种属性选择器的使用 12345678910使用方法: [attr] &#123; 属性名: 值; 属性名: 值; ...&#125;[title] &#123; &#125; 例如: 123456789101112CSS部分:&lt;style&gt; [name] &#123; color: red; &#125;&lt;/style&gt;HTML部分: &lt;div&gt; hello1 &lt;/div&gt;&lt;div name="peter"&gt; hello1 &lt;/div&gt;&lt;div title="haha"&gt; hello1 &lt;/div&gt;&lt;div&gt; hello1 &lt;/div&gt; 2. 第二种属性选择器的使用 1234567使用方法:E[attr=val] &#123; 属性名: 值; 属性名: 值; ...&#125; 例如: 123456789101112CSS部分:&lt;style&gt; [name="peter"] &#123; color: red; &#125;&lt;/style&gt;HTML部分: &lt;div&gt; hello1 &lt;/div&gt;&lt;div name="peter"&gt; hello1 &lt;/div&gt;&lt;div name="bill"&gt; hello1 &lt;/div&gt;&lt;div&gt; hello1 &lt;/div&gt; 3.4 伪类选择器1. 伪类选择器 常用的伪类选择器有hover，表示鼠标悬浮在元素上时的状态。 12345678910111213141516171819202122CSS部分: &lt;style&gt; .box1 &#123; width:100px; height:100px; background:gold; &#125; .box1:hover &#123; width:300px; &#125;&lt;/style&gt;HTML部分: &lt;div class="box1"&gt;别看村子不咋大呀， 有山有水有树林， 邻里相亲多和睦， 老少爷们也合群&lt;/div&gt;补充: #input:focus &#123; outline: none; border: 2px solid red;&#125; 总结: CSS 选择器的主要目的是: 获取 HTML 元素, 获取到后给当前元素添加样式. CSS 选择器的种类非常多, 一般我们用不上, 把常用的学会即可. 标签选择器尽量少用, 覆盖面巨大. 不利于我们样式的单独调整. class 类选择器是经常使用的选择器. 可以多多练习 层级选择器 一般配合类选择器或者其他的选择器一起使用. 常用来获取大容器里面没有明确定义类名的元素 id 选择器偶尔使用, 使用它往往就是利用他的唯一性. 获取单个某个标签使用. 伪类选择器是需要设置特殊阶段的效果时, 添加的选择器, 知道即可 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;style type="text/css"&gt; a:link &#123;color: red&#125; /* 未访问时的状态 */ a:visited &#123;color: orange&#125; /* 已访问过的状态 */ a:hover &#123;color: pink&#125; /* 鼠标移动到链接上时的状态 */ a:active &#123;color: yellow&#125; /* 鼠标按下去时的状态 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;b&gt;&lt;a href="/index.html" target="_blank"&gt;这是一个链接。&lt;/a&gt;&lt;/b&gt; &lt;/p&gt; &lt;p&gt; &lt;b&gt;注释：&lt;/b&gt; 在 CSS 定义中，a:hover 必须位于 a:link 和 a:visited 之后，这样才能生效！ &lt;/p&gt; &lt;p&gt; &lt;b&gt;注释：&lt;/b&gt; 在 CSS 定义中，a:active 必须位于 a:hover 之后，这样才能生效！ &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 注意嵌套规则: 块级元素 可以包含内联元素或某些块级元素, 但是内联元素不能包含块级元素,它只能包含其他内联元素 有几个特殊的块级元素只能包含内联元素,不能包含块级元素. 如h1, h2, h3, h4, h5, h6, p li 内可以包含 div 块级元素与块级元素并列 , 内联元素与内联元素并列. 4. 初始化CSS为什么要初始化CSS？ ​ 建站老手都知道，这是为了考虑到浏览器的兼容问题，其实不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 ​ 最简单的初始化方法就是： {padding: 0; margin: 0;} 。有很多人也是这样写的。这确实很简单，但有人就会感到疑问：号这样一个通用符在编写代码的时候是快，但如果网站很大，CSS样式表文件很大，这样写的话，他会把所有的标签都初始化一遍，这样就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间。 ​ 写过css的都知道每个网页引进的css首先都需要初始化，而出名的css reset有YUI css reset（QQ、淘宝等都出现他的影子），业内用的最多的还有Erik Meyer’s CSS Reset。 ​ CSS初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，所以开发时的第一件事可能就是如何把它们统一。如果没对CSS初始化往往会出现浏览器之间的页面差异。每次新开发网站或新网页时候通过初始化CSS样式的属性，为我们将用到的CSS或html标签更加方便准确，使得我们开发网页内容时更加方便简洁，同时减少CSS代码量，节约网页下载时间。 ​ 雅虎工程师提供的CSS初始化示例代码 ​ body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td { margin:0; padding:0; } 4. CSS进阶布局常用属性样式: 属性 作用 举例 width 设置元素(标签)的宽度 width: 200px; height 设置元素(标签)的高度 height: 200px; background 设置元素背景色或者背景图片(详看下面) background: pink; border 设置元素四周的边框 border: 1px solid pink; border-top 设置元素顶部边框 border-top: 1px solid/ dashed pink; border-left 设置元素左边边框 border-left: 1px solid pink; border-right 设置元素右边边框 border-right: 1px solid pink; border-bottom 设置元素底部边框 border-bottom: 1px solid pink; 文本常用样式属性: color 设置文字的颜色 color: red; font-size 设置文字的大小 font-size: 12px; font-family 设置文字的字体 font-family: ‘Microsoft Yahei’; (微软雅黑) font-weight 设置文字是否加粗 font-weight: bold; (bold:加粗 normal: 正常) line-height 设置文字的行高 line-height: 24px; (文字高度加上文字上下间距共计24px) text-decoration 设置文字的下划线 text-decoration:none; (取消下划线) 提示:样式中的注释 123456/* 设置头部的样式 */.header&#123; width:960px; height:80px; background:gold;&#125; 浮动: ( float ) 我们有时候为了让一行能够显示多个元素, 会设置元素的float属性: 先来回顾一下 block 元素和 inline 元素在页面中的排列方式: block 元素通常被实现为独立的一块, 独占一行, 多个 block 元素会各自新起一行, 默认 block 元素宽度自动填满其父元素宽度. block 元素可以设置 width, height, margin, padding 属性. inline 元素不会独占一行, 多个相邻的行内元素会排列在一行里, 知道一行排列不下, 才会新换一行, 其宽度随元素的内容而变化. inline 元素设置width, height属性无效. inline 元素的margin 和 padding 属性. 水平方向的padding-left, padding-right, margin-left, margin-right 都产生边距效果; 但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom 不会产生边距效果. 常见的块级元素有 div, form , table, p, h1~h5, ol, ul等 常见的内联元素有 span, a, strong, em, label, input, select, textarea, img, br等. 只有绝对定位( absolute )和浮动( float ) 才会脱离文档流 需要注意的是: 使用 float 脱离文档流时, 其他盒子会无视这个元素, 但其他盒子内的文本依然会为这个元素让出位置, 环绕在周围(可以说是部分无视). 而对于使用 position:absolute 脱离文档流的元素, 其他盒子与其他盒子内的文本都会无视它(可以说是完全无视) 浮动的表现 : ​ 定义: 浮动的框可以向左或向右移动, 直到它的外边缘碰到包含框或另一个浮动框的边框为止. 由于浮动框不在文档的普通流中,所以文档的普通流中的浮动框之后的块框表现的就像浮动框不存在一样. (注意 这里是块框而不是内联元素; 浮动框只对它后面的元素造成影响 ) 注意: 当初float 被设计的时候就是用来完成文本环绕的效果, 所以文本不会被挡住, 这是 float 的特性, 即 float 是一种不彻底的脱离文档流的方式. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div1 &#123; width: 100px; height: 100px; background-color: pink; &#125; .div2 &#123; width: 200px; height: 100px; background-color: blue; &#125; .div3 &#123; width: 100px; height: 200px; background-color: green; &#125; .div4 &#123; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="div1"&gt;&lt;/div&gt; &lt;div class="div2"&gt;&lt;/div&gt; &lt;div class="div3"&gt;&lt;/div&gt; &lt;div class="div4"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 特别注意 设置某一个元素为float 之后, 当前元素是否往前一个位置飘动,取决于上一个元素是否设置了float,如果设置了则飘动,如果没有设置,则还是在原来的位置, 只是飘起来, 不飘动. 如果一个容器中有两个子元素, 两个子元素都设置浮动浮起来之后,则容器会被压缩为一点. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 300px; background-color: pink; &#125; .sub1 &#123; width: 100px; height: 100px; background-color: limegreen; float: left; &#125; .sub2 &#123; width: 100px; height: 100px; background-color: olive; float: left; &#125; .box2 &#123; width: 400px; height: 30px; background-color: orangered; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="sub1"&gt;&lt;/div&gt; &lt;div class="sub2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 补充: 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 css 浮动: 请看下图，当把框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘： 再请看下图，当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。 如果把所有三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。 如下图所示，如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”： 5. CSS布局演示通过样式,并且参照下图, 可以把之前写的布局作进一步的调整, 完成最终的布局效果: 参考文字: 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width:285px; height: 310px; border-bottom: 1px solid #c8dcf2; border-top: 1px solid #c8dcf2; &#125; .header &#123; width:285px; height: 40px; &#125; .header h3 &#123; margin:0px; font-family: 'Microsoft Yahei'; font-size: 16px; color: #172c45; line-height: 40px; float: left; &#125; .header a &#123; font-size: 12px; font-family: 'Microsoft Yahei'; color: #172c45; text-decoration: none; float: right; line-height: 40px; &#125; p &#123; font-size: 12px; font-family: 'Microsoft Yahei'; color: #737373; line-height: 20px; height:190px; width: 100%; &#125; img &#123; height:80px; width:100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="header"&gt; &lt;h3&gt;今日头条&lt;/h3&gt; &lt;a href="#"&gt;更多&amp;gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;img src="./images/banner.jpg" alt="banner"&gt; &lt;p&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解前端]]></title>
    <url>%2F2016%2F07%2F19%2F2016-7-19-html%2F</url>
    <content type="text"><![CDATA[一. 了解前端1. 什么是前端前端即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5，CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，完美的动效设计，给用户带来极高的用户体验。 2. 前端三大块 这三个是前端开发中最基本也是最必须的三个技能。前端的开发中，在页面的布局时， HTML将元素进行定义，CSS对展示的元素进行定位，再通过JavaScript实现相应的效果和交互。虽然表面看起来很简单，但这里面需要掌握的东西绝对不会少。在进行开发前，需要对这些概念弄清楚、弄明白，这样在开发的过程中才会得心应手。 Html指的是超文本标记语言 (Hyper Text Markup Language)，这个也是我们网页最常用普通的语言了，经历了多个版本的发展，已经发展到5.0版了, 即HTML5。 Css级联样式表（Cascading Style Sheet）简称“CSS”，通常又称为“风格样式表（Style Sheet）”，它是用来进行网页风格设计的。比如，如果想让链接字未点击时是蓝色的，当鼠标移上去后字变成红色的且有下划线，这就是一种风格。通过设立样式表，可以统一地控制HTML中各标志的显示属性。级联样式表可以使人更能有效地控制网页外观。使用级联样式表，可以扩充精确指定网页元素位置，外观以及创建特殊效果的能力。 JavaScriptJavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[辨析 Sass 中的 Map 和 List]]></title>
    <url>%2F2016%2F07%2F12%2F2016-7-12-demo%2F</url>
    <content type="text"><![CDATA[如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。 使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。 测试表格 Variable Description site Sitewide information. page Page specific information and custom variables set in front-matter. config Site configuration theme Theme configuration. Inherits from site configuration. _ (single underscore) Lodash library path Path of current page url Full URL of current page env Environment variables 语法比较 测试标题 在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 min-width、max-width、font-size 和 line-height 四个样式。 Map 语法下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。 1234567891011121314151617181920212223242526$breakpoint-map: ( small: ( min-width: null, max-width: 479px, base-font: 16px, vertical-rhythm: 1.3 ), medium: ( min-width: 480px, max-width: 959px, base-font: 18px, vertical-rhythm: 1.414 ), large: ( min-width: 960px, max-width: 1099px, base-font: 18px, vertical-rhythm: 1.5 ), xlarge: ( min-width: 1100px, max-width: null, base-font: 21px, vertical-rhythm: 1.618 )); 多重列表语法下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 nth() 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。 123456$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618)); 遍历比较 测试标题 从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？ 遍历 Map我们可以使用如下的代码遍历 Map： 1@each $label, $map in $breakpoint-map &#123;&#125; 这里的变量 $label 和 $map 会随着对 $breakpoint-map 的遍历被动态地赋值，$label 将会被赋值为 $breakpoint-map 的 Key，而 $map 会被赋值为 $breakpoint-map 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 map-get() 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。 具体的做法就是使用 @each 遍历 Map，然后使用 map-get() 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历： 123456@each $label, $map in $breakpoint-map &#123; $min-width: map-get($map, min-width); $max-width: map-get($map, max-width); $base-font: map-get($map, base-font); $vertical-rhythm: map-get($map, vertical-rhythm);&#125; 遍历多重列表遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 map-get() 函数取特定值，直接遍历一遍即可获得特定值。 因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 map-get()，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符： 12@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#125; 慎用多重列表 测试标题 经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。 遗漏键值如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况： 1234567891011121314151617181920$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, 21px, 1.618));p &#123; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123; @if $min-width &#123; @include breakpoint( $min-width ) &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125; @else &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125;&#125; 当我们尝试运行这段代码时，结果肯定是错误地，因为在 $breakpoint-list 的最后一行，xlarge 被赋值给了 $label，1100px 被赋值给了 $min-width，21px 被赋值给了 $max-width, 1.618 被赋值给了 $base-font，最终导致 $vertical-rhythm 没有被赋值，结果就是 font-size 的属性值是错的，line-height 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。 如果我们使用 Map 来代替这里的多重列表，那么使用 map-get() 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。 查找特定列表在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 map-get() 函数可以快速定位到特定子 Map： 1$medium-map: map-get($maps, medium); 但如果要获取多种列表 medium 列表，麻烦可就大了： 123456789@function get-list($label) &#123; @each $list in $breakpoint-list &#123; @if nth($list, 1) == $label &#123; @return $list; &#125; &#125; @return null;&#125;$medium-list: get-list(medium); 这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 null。这实际上就是手工实现了 map-get() 的逻辑。 缺少原生的 Map 函数Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 map-merge() 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 join() 或 append() 来增加新列表，从而模拟出 map-merge() 的效果。 另一个实用的 Map 函数就是 map-has-key()，对于依赖 map-get() 的自定义函数来说，map-has-key() 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。 总结 Test Title 相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。 虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
